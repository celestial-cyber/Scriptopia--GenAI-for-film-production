from moviepy.editor import ImageSequenceClip
from PIL import Image
import os

from video_engine.llm_client import request_video_from_llm


def regenerate_video(frame_dir, frame_path, output_path, intent):
    """Try to generate the video by asking an LLM-backed API, falling back to local assembly.

    `intent` should be a dict and may contain `fps` and other options.
    """
    images = [os.path.join(frame_dir, f) for f in frame_path]

    # Filter out corrupted frames
    valid_images = []
    for img_path in images:
        try:
            # Try to open and verify the image
            with Image.open(img_path) as img:
                img.verify()
            valid_images.append(img_path)
        except Exception as e:
            print(f"[WARN] Skipping corrupted frame: {img_path} ({str(e)})")

    if not valid_images:
        print("[ERROR] No valid frames found!")
        return

    print(f"[INFO] Using {len(valid_images)} valid frames (skipped {len(images) - len(valid_images)})")

    # Attempt to request LLM to form the video
    try:
        ok = request_video_from_llm(valid_images, intent, output_path)
        if ok:
            print(f"[INFO] Video regenerated by LLM and saved at {output_path}")
            return
        else:
            print("[INFO] LLM generation skipped or failed; falling back to local assembly")
    except Exception as e:
        print(f"[WARN] LLM generation error: {e}; falling back to local assembly")

    # Fallback: assemble locally using moviepy
    fps = intent.get("fps") if isinstance(intent, dict) else None
    if not fps:
        fps = 24

    clip = ImageSequenceClip(valid_images, fps=fps)
    clip.write_videofile(output_path, codec="libx264", verbose=False, logger=None)

    print(f"[INFO] Video regenerated at {output_path}")
